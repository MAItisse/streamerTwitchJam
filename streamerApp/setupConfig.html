<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>OBS Window Boundaries with Parenting and Resizing</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            position: relative;

            background-color: #111133;
            user-select: none;
        }

        .window {
            position: absolute;
            border: 3px solid #000;
            background-color: #3377;
            border-radius: 10px;

            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;

            transition: 0.2s all ease-out;
        }

        .selected {
            border-color: green !important;
            background-color: #3578;
        }

        .boundary {
            position: absolute;
            border: 2px dashed red;
            border-radius: 10px;
            cursor: pointer;
            transition: border-color 0.2s, background-color 0.2s, width 0.1s, height 0.1s;
            transition-timing-function: ease-out;
        }

        .boundary-selected {
            border-color: blue !important;
            background-color: rgba(0, 0, 255, 0.1);
        }

        .new-parent {
            position: absolute;
            border: 2px dashed green;
            background-color: rgba(0, 255, 0, 0.1);
            cursor: move;
        }

        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: red;
            right: 0;
            bottom: 0;
            cursor: nwse-resize;
        }

        .ui-controls {
            position: fixed;
            top: 20px;
            padding: 10px;
            left: 50%;
            translate: -50% 0;
            display: flex;

            background-color: #333355;
            border-radius: 10px;
            box-shadow: 4px 4px 2px black;

            z-index: 1000;
        }

        button {
            margin: 10px;
            font-size: 1.3rem;

            background-color: #445;
            color: white;
            border: 3px #222244 solid;
            border-radius: 10px;
            padding: 5px;

            transition: all 0.2s ease-out;
        }

        button:hover {
            background-color: #223;
        }

        button.active {
            background-color: #232;
        }

        #container {
            position: relative;
            width: 100%;
            height: 100vh;
        }
    </style>
    <!-- Include marked.js for Markdown conversion -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>

<body>
    <div class="ui-controls">
        <!-- <button id="select-item-btn">Select Item</button> -->
        <button id="draw-boundary-btn">Draw Boundary</button>
        <!-- <button id="assign-child-btn">Assign Child to Parent</button> -->
        <button id="assign-child-boundary-btn">Assign Child to Boundary</button>
        <!-- <button id="create-parent-box">Create New Parent Box</button> -->
        <!-- <button id="assign-parent-boundary-btn">Assign Parent to Boundary</button> -->
        <button id="save-boundaries">Save Boundaries</button>
        <!-- <pre id="output"></pre> -->
    </div>

    <div id="container"></div>

    <script>
        let selectedElement = null;
        let selectedChild = null;
        let selectedBoundary = null;
        let parentItem = null;
        let parentIdCounter = 1000; // Start parent IDs from 1000
        let boundaries = [];
        let assignedChildren = {};  // Track children for each parent
        let childBoundaries = {};   // Track child boundary assignments
        let isDrawingBoundary = false;
        let currentBoundaryDiv = null;
        let isResizing = false;     // Flag to differentiate between resizing and dragging

        // Function to fetch and dynamically create HTML elements based on obsConfig.json
        async function loadObsConfig() {
            try {
                const response = await fetch('obsConfig.json'); // Fetch JSON file
                const config = await response.json();           // Parse JSON

                // Loop through each window config and create corresponding div elements
                config.forEach(windowData => {
                    const windowDiv = document.createElement('div');
                    windowDiv.classList.add('window');
                    windowDiv.style.width = `${windowData.width}px`;
                    windowDiv.style.height = `${windowData.height}px`;
                    windowDiv.style.left = `${windowData.xLocation}px`;
                    windowDiv.style.top = `${windowData.yLocation}px`;
                    windowDiv.style.zIndex = windowData.windowId;

                    // Use textContent or DOM methods instead of innerHTML
                    const titleDiv = document.createElement('div');
                    // Convert window name to Markdown and then to HTML safely
                    const markdownTitle = `**${windowData.windowName}**`;
                    const renderedTitle = marked.parse(markdownTitle);
                    titleDiv.innerHTML = renderedTitle;
                    windowDiv.appendChild(titleDiv);

                    // Attach a click event for selecting the item
                    windowDiv.addEventListener('click', (event) => {
                        event.stopPropagation(); // Stop event propagation to avoid global click handling
                        selectChild(windowDiv, windowData.windowId);
                    });

                    document.getElementById('container').appendChild(windowDiv);
                });
            } catch (error) {
                console.error('Error loading the OBS config:', error);
            }
        }

        // Function to select a child
        function selectChild(element, windowId) {
            if (selectedChild) {
                selectedChild.classList.remove('selected');
            }
            selectedChild = element;
            selectedChild.classList.add('selected');
            console.log(`Selected child windowId: ${windowId}`);
        }

        // Function to select a boundary
        function selectBoundary(element, boundaryId) {
            if (selectedBoundary) {
                selectedBoundary.classList.remove('boundary-selected');
            }
            selectedBoundary = element;
            selectedBoundary.classList.add('boundary-selected'); // Add boundary-selected class for visual feedback
            console.log(`Selected boundary with id: ${boundaryId}`);
        }

        // Function to start drawing a boundary
        function drawBoundary() {
            isDrawingBoundary = true;
            document.getElementById("draw-boundary-btn").classList.add("active");
            document.addEventListener('mousedown', startDrawingBoundary);
        }

        function startDrawingBoundary(e) {
            if (!isDrawingBoundary) return;
            currentBoundaryDiv = document.createElement('div');
            currentBoundaryDiv.classList.add('boundary');
            currentBoundaryDiv.style.left = `${e.pageX}px`;
            currentBoundaryDiv.style.top = `${e.pageY}px`;
            document.getElementById('container').appendChild(currentBoundaryDiv);

            const startX = e.pageX;
            const startY = e.pageY;

            document.addEventListener('mousemove', draw);
            document.addEventListener('mouseup', stopDrawingBoundary);

            function draw(e) {
                const width = e.pageX - startX;
                const height = e.pageY - startY;
                currentBoundaryDiv.style.width = `${Math.abs(width)}px`;
                currentBoundaryDiv.style.height = `${Math.abs(height)}px`;
                currentBoundaryDiv.style.left = `${Math.min(e.pageX, startX)}px`;
                currentBoundaryDiv.style.top = `${Math.min(e.pageY, startY)}px`;
            }

            function stopDrawingBoundary(e) {
                isDrawingBoundary = false;
                document.removeEventListener('mousemove', draw);
                document.removeEventListener('mouseup', stopDrawingBoundary);
                document.getElementById("draw-boundary-btn").classList.remove("active");

                // Assign a unique ID to the boundary
                const boundaryId = `boundary-${Date.now()}`;
                currentBoundaryDiv.dataset.boundaryId = boundaryId;

                // Add click event for selecting the boundary
                currentBoundaryDiv.addEventListener('click', (event) => {
                    event.stopPropagation(); // Stop event propagation to avoid global click handling
                    selectBoundary(event.currentTarget, boundaryId); // Use event.currentTarget
                });

                // Store the boundary details
                boundaries.push({
                    windowId: boundaryId,  // Use boundaryId as windowId
                    xLocation: currentBoundaryDiv.style.left,
                    yLocation: currentBoundaryDiv.style.top,
                    width: currentBoundaryDiv.style.width,
                    height: currentBoundaryDiv.style.height,
                    isBoundary: true
                });

                currentBoundaryDiv = null;  // Reset the current boundary
            }
        }

        // Assign a child directly to a boundary
        function assignChildToBoundary() {
            if (!selectedChild) {
                alert("Please select a child to assign to a boundary.");
                return;
            }
            if (!selectedBoundary) {
                alert("Please select a boundary to assign the child to.");
                return;
            }

            const boundaryId = selectedBoundary.dataset.boundaryId;
            if (!childBoundaries[boundaryId]) {
                childBoundaries[boundaryId] = [];
            }

            // Assign the child to this boundary
            childBoundaries[boundaryId].push(selectedChild);

            console.log(`Assigned child with windowId: ${selectedChild.style.zIndex} to boundary with boundaryId: ${boundaryId}`);
            alert("This button did a thing, but idk how to display feedback for that yet :P")
        }

        // Save boundaries and include child elements
        document.getElementById('save-boundaries').addEventListener('click', () => {
            // Update boundaries with current positions and sizes
            boundaries = boundaries.map(boundary => {
                const element = document.querySelector(`[data-boundary-id='${boundary.windowId}']`) || document.querySelector(`[style*='z-index: ${boundary.windowId};']`);
                if (element) {
                    boundary.xLocation = element.style.left;
                    boundary.yLocation = element.style.top;
                    boundary.width = element.style.width;
                    boundary.height = element.style.height;
                }
                return boundary;
            });

            // Loop through each parent and store its children
            boundaries.forEach(boundary => {
                if (assignedChildren[boundary.windowId]) {
                    boundary.children = assignedChildren[boundary.windowId].map(child => ({
                        windowId: child.style.zIndex,
                        xLocation: child.style.left,
                        yLocation: child.style.top,
                        width: child.style.width,
                        height: child.style.height
                    }));
                }
            });

            // Store child-boundary assignments (for children without parents)
            Object.keys(childBoundaries).forEach(boundaryId => {
                const children = childBoundaries[boundaryId];
                children.forEach(child => {
                    boundaries.push({
                        windowId: child.style.zIndex,
                        boundaryId: boundaryId,
                        xLocation: child.style.left,
                        yLocation: child.style.top,
                        width: child.style.width,
                        height: child.style.height
                    });
                });
            });

            const config = JSON.stringify(boundaries, null, 4);
            alert(config);
        });

        // Button event listeners
        document.getElementById('draw-boundary-btn').addEventListener('click', drawBoundary);
        document.getElementById('assign-child-boundary-btn').addEventListener('click', assignChildToBoundary);

        // Call the function to load and generate the HTML
        loadObsConfig();
    </script>
</body>

</html>
