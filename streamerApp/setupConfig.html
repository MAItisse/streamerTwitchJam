<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OBS Window Boundaries with Parenting and Resizing</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            position: relative;
        }
        .window {
            position: absolute;
            border: 1px solid #000;
            background-color: rgba(0, 0, 255, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        .boundary {
            position: absolute;
            border: 2px dashed red;
        }
        .new-parent {
            position: absolute;
            border: 2px dashed green;
            background-color: rgba(0, 255, 0, 0.1);
        }
        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: red;
            right: 0;
            bottom: 0;
            cursor: nwse-resize;
        }
        .selected {
            border-color: green !important;
        }
        .ui-controls {
            position: fixed;
            top: 0;
            left: 0;
            padding: 10px;
            background-color: white;
            border-bottom: 1px solid #ccc;
        }
    </style>
</head>
<body>
    <div class="ui-controls">
        <button id="select-item-btn">Select Item</button>
        <button id="draw-boundary-btn">Draw Boundary</button>
        <button id="assign-child-btn">Assign Child</button>
        <button id="create-parent-box">Create New Parent Box</button>
        <button id="assign-parent-boundary-btn">Assign Parent to Boundary</button>
        <button id="save-boundaries">Save Boundaries</button>
        <pre id="output"></pre>
    </div>

    <div id="container"></div>

    <script>
        let selectedElement = null;
        let parentItem = null;
        let parentIdCounter = 1000;  // Start parent IDs from 1000
        let boundaries = [];
        let assignedChildren = []; // To track children assigned to the parent
        let isDrawingBoundary = false;
        let currentBoundaryDiv = null;

        // Function to fetch and dynamically create HTML elements based on obsConfig.json
        async function loadObsConfig() {
            try {
                const response = await fetch('obsConfig.json'); // Fetch JSON file
                const config = await response.json(); // Parse JSON

                // Loop through each window config and create corresponding div elements
                config.forEach(windowData => {
                    const windowDiv = document.createElement('div');
                    windowDiv.classList.add('window');
                    windowDiv.style.width = `${windowData.width}px`;
                    windowDiv.style.height = `${windowData.height}px`;
                    windowDiv.style.left = `${windowData.xLocation}px`;
                    windowDiv.style.top = `${windowData.yLocation}px`;
                    windowDiv.innerHTML = `<strong>${windowData.windowName}</strong>`;
                    windowDiv.style.zIndex = windowData.windowId;

                    // Attach a click event for selecting the item
                    windowDiv.addEventListener('click', () => selectItem(windowDiv, windowData.windowId));

                    document.getElementById('container').appendChild(windowDiv);
                });
            } catch (error) {
                console.error('Error loading the OBS config:', error);
            }
        }

        // Function to select an item
        function selectItem(element, windowId) {
            if (selectedElement) {
                selectedElement.classList.remove('selected');
            }
            selectedElement = element;
            selectedElement.classList.add('selected');
            console.log(`Selected windowId: ${windowId}`);
        }

        // Function to start drawing a boundary
        function drawBoundary() {
            isDrawingBoundary = true;
            document.addEventListener('mousedown', startDrawingBoundary);
        }

        function startDrawingBoundary(e) {
            if (!isDrawingBoundary) return;
            currentBoundaryDiv = document.createElement('div');
            currentBoundaryDiv.classList.add('boundary');
            currentBoundaryDiv.style.left = `${e.pageX}px`;
            currentBoundaryDiv.style.top = `${e.pageY}px`;
            document.getElementById('container').appendChild(currentBoundaryDiv);

            const startX = e.pageX;
            const startY = e.pageY;

            document.addEventListener('mousemove', draw);
            document.addEventListener('mouseup', stopDrawingBoundary);

            function draw(e) {
                const width = e.pageX - startX;
                const height = e.pageY - startY;
                currentBoundaryDiv.style.width = `${Math.abs(width)}px`;
                currentBoundaryDiv.style.height = `${Math.abs(height)}px`;
                currentBoundaryDiv.style.left = `${Math.min(e.pageX, startX)}px`;
                currentBoundaryDiv.style.top = `${Math.min(e.pageY, startY)}px`;
            }

            function stopDrawingBoundary(e) {
                isDrawingBoundary = false;
                document.removeEventListener('mousemove', draw);
                document.removeEventListener('mouseup', stopDrawingBoundary);

                // Store the boundary details
                boundaries.push({
                    windowId: null,  // No windowId since it's a custom boundary
                    xLocation: currentBoundaryDiv.style.left,
                    yLocation: currentBoundaryDiv.style.top,
                    width: currentBoundaryDiv.style.width,
                    height: currentBoundaryDiv.style.height,
                    isBoundary: true
                });

                currentBoundaryDiv = null;  // Reset the current boundary
            }
        }

        // Assign a child to the parent
        function assignChild() {
            if (!parentItem || !selectedElement) {
                alert("Please select a parent and a child.");
                return;
            }
            if (parentItem === selectedElement) {
                alert("You can't assign the parent to itself!");
                return;
            }

            // Add child to the assignedChildren list
            assignedChildren.push(selectedElement);

            console.log(`Assigned child with windowId: ${selectedElement.style.zIndex} to parent with windowId: ${parentItem.style.zIndex}`);
        }

        // Assign parent to boundary
        function assignParentToBoundary() {
            if (!parentItem || !selectedElement) {
                alert("Please select a boundary and a parent.");
                return;
            }
            if (selectedElement.classList.contains('boundary')) {
                const boundaryRect = selectedElement.getBoundingClientRect();
                const parentRect = parentItem.getBoundingClientRect();

                // Adjust the parent to fit inside the boundary
                if (parentRect.left < boundaryRect.left || parentRect.top < boundaryRect.top ||
                    parentRect.right > boundaryRect.right || parentRect.bottom > boundaryRect.bottom) {
                    parentItem.style.left = `${boundaryRect.left}px`;
                    parentItem.style.top = `${boundaryRect.top}px`;
                    parentItem.style.width = `${boundaryRect.width}px`;
                    parentItem.style.height = `${boundaryRect.height}px`;
                }

                console.log(`Assigned parent with windowId: ${parentItem.style.zIndex} to boundary`);
            }
        }

        // Create a new empty parent box
        function createNewParentBox() {
            const newParentDiv = document.createElement('div');
            newParentDiv.classList.add('new-parent');
            newParentDiv.style.width = '200px';
            newParentDiv.style.height = '200px';
            newParentDiv.style.left = '50px';
            newParentDiv.style.top = '50px';
            newParentDiv.style.zIndex = parentIdCounter;  // Assign a new parent ID starting from 1000
            newParentDiv.innerHTML = `<strong>Parent ${parentIdCounter}</strong>`;
            parentIdCounter++;  // Increment parent ID counter

            const resizeHandle = document.createElement('div');
            resizeHandle.classList.add('resize-handle');
            newParentDiv.appendChild(resizeHandle);

            // Allow the new parent to be selected
            newParentDiv.addEventListener('click', () => {
                if (selectedElement) {
                    selectedElement.classList.remove('selected');
                }
                newParentDiv.classList.add('selected');
                selectedElement = newParentDiv;
                parentItem = newParentDiv;
                console.log(`Selected parent with windowId: ${newParentDiv.style.zIndex}`);
            });

            // Enable resizing using the handle
            enableResize(newParentDiv, resizeHandle);

            document.getElementById('container').appendChild(newParentDiv);

            // Store the new parent boundary details
            boundaries.push({
                windowId: newParentDiv.style.zIndex,  // The new parent ID
                xLocation: newParentDiv.style.left,
                yLocation: newParentDiv.style.top,
                width: newParentDiv.style.width,
                height: newParentDiv.style.height,
                isBoundary: false
            });
        }

        // Enable resizing functionality
        function enableResize(parentDiv, resizeHandle) {
            resizeHandle.addEventListener('mousedown', (e) => {
                e.preventDefault();
                document.addEventListener('mousemove', resize);
                document.addEventListener('mouseup', stopResize);

                function resize(e) {
                    const newWidth = e.clientX - parentDiv.getBoundingClientRect().left;
                    const newHeight = e.clientY - parentDiv.getBoundingClientRect().top;
                    parentDiv.style.width = `${newWidth}px`;
                    parentDiv.style.height = `${newHeight}px`;

                    // Ensure assigned children remain within the resized parent
                    assignedChildren.forEach(child => {
                        const childRect = child.getBoundingClientRect();
                        const parentRect = parentDiv.getBoundingClientRect();

                        if (childRect.right > parentRect.right) {
                            child.style.left = `${parentRect.width - childRect.width}px`;
                        }
                        if (childRect.bottom > parentRect.bottom) {
                            child.style.top = `${parentRect.height - childRect.height}px`;
                        }
                    });
                }

                function stopResize() {
                    document.removeEventListener('mousemove', resize);
                    document.removeEventListener('mouseup', stopResize);
                }
            });
        }

        // Save boundaries and output as JSON
        document.getElementById('save-boundaries').addEventListener('click', () => {
            const boundariesConfig = JSON.stringify(boundaries, null, 4);
            document.getElementById('output').textContent = boundariesConfig;
        });

        // Button event listeners
        document.getElementById('draw-boundary-btn').addEventListener('click', drawBoundary);
        document.getElementById('assign-child-btn').addEventListener('click', assignChild);
        document.getElementById('assign-parent-boundary-btn').addEventListener('click', assignParentToBoundary);
        document.getElementById('create-parent-box').addEventListener('click', createNewParentBox);

        // Call the function to load and generate the HTML
        loadObsConfig();
    </script>
</body>
</html>
