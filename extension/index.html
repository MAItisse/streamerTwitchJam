<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Chat Plays OBS</title>
    <script src="https://extension-files.twitch.tv/helper/v1/twitch-ext.min.js"></script>
    <script type="text/javascript" src="marked.min.js"></script>
    <script type="text/javascript" src="purify.min.js"></script>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: transparent;
            font-family: Arial, sans-serif;
            overflow: hidden;
            position: relative;

            /* background-image: url("https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fassets.change.org%2Fphotos%2F4%2Fdw%2Fbs%2FukdWbStGWSBsTBo-1600x900-noPad.jpg%3F1609977468&f=1&nofb=1&ipt=15b94c20056b770a201772bb214fdfd2182a64e1ad8aeffb5f6cae63ad7bc281&ipo=images"); */
        }

        #obs-container {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .draggableWindow {
            --r: 0;
            --g: 0;
            --b: 255;
            background-color: rgba(var(--r), var(--g), var(--b), 0.1);
            position: absolute;
            box-shadow: black 2px 2px 10px;
            transition: box-shadow 0.3s, backdrop-filter 0.5s ease-in-out, background-color 0.5s ease-in-out, box-shadow 0.3s ease-in-out;
            border-radius: 4px;
            backdrop-filter: blur(5px);
        }

        .draggableWindow:hover {
            backdrop-filter: blur(20px);
            background-color: rgba(var(--r), var(--g), var(--b), 0.357);
            box-shadow: black 10px 10px 10px;
        }

        body {
            opacity: 0;
            transition: opacity 0.2s;
        }

        body:hover {
            opacity: 1;
        }

        #info-popup {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #1b1b33;
            padding: 20px;
            /* max-width: 200px; */
            /* max-height: 200px; */
            z-index: 1000;
            /* Ensure it appears above other elements */
            border-radius: 5px;
            box-shadow: black 8px 8px 8px;
            opacity: 0;
            transition: opacity 10s ease-in-out;
            overflow-y: auto;
            /* Enable vertical scrolling */

            color: white;
            background-color: #0f1023;
        }

        .follow_button {
            background-color: #9146FF;
            /* Twitch purple */
            border: none;
            color: white;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            font-size: 14px;
        }

        .follow_button:hover {
            background-color: #772ce8;
        }

        #info-popup:not(.hidden) {
            opacity: 1;
            pointer-events: auto;
        }

        .hidden {
            display: none;
        }

        .infoIcon {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 16px;
            height: 16px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            font-size: 12px;
            text-align: center;
            line-height: 16px;
            border-radius: 50%;
            cursor: pointer;
            user-select: none;
        }

        /* New Popup Menu Styles */
        .popup-menu {
            position: fixed;
            top: 50px;
            left: 10px;
            height: 30px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 1001;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: height 0.2s ease-in-out;
            cursor: pointer;
            overflow: hidden;
        }

        .popup-menu:hover {
            max-width: 50vw;
            height: 100px;
            border-radius: 8px;
            padding: 10px;
        }

        /* Initially hide the popup menu */
        .popup-menu.hidden {
            opacity: 0;
            visibility: hidden;
        }

        /* Show the popup menu */
        .popup-menu.visible {
            opacity: 1;
            visibility: visible;
        }

        /* Bits Button Styles */
        .bits-button {
            background-color: #9146FF;
            /* Twitch purple */
            border: none;
            color: white;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            font-size: 14px;
        }

        .bits-button:hover {
            background-color: #772ce8;
        }

        #bits-buttons-container {
            display: flex;
            transition: max-width 0.5s;
            width: auto;
            height: 70px;
            max-width: 0px;
            overflow: hidden;
        }

        .bits-button * {
            opacity: 0;
            transition: opacity 0.5s;
        }

        #top-left-menu:hover .bits-button * {
            opacity: 1;
        }

        #top-left-menu:hover #bits-buttons-container {
            max-width: 100vw;
        }

        .top-text {
            color: #acf4ac;
        }

        .bottom-text {
            color: #fdad94;
        }
    </style>
</head>

<body>
    <div id="obs-container">
    </div>
    <div id="info-popup" class="hidden"></div>
    <!-- New Popup Menu -->
    <!-- TODO: ADD BACK HIDDEN -->
    <!-- TODO: IF THIS IS PUSHED FEEL FREE TO YELL AT VIV -->
    <!-- TODO: VIV MESSED UP :P :P :P -->
    <div id="top-left-menu" class="popup-menu">
        <!-- Diamond SVG Icon -->
        <div id="diamond-icon" class="diamond-icon">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 18L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z"
                    stroke="#FFFFFF" stroke-width="2" stroke-linecap="round" stroke-opacity=".5" stroke-linejoin="round"
                    fill="#9146FF" />
            </svg>
        </div>

        <!-- Bits buttons container (hidden by default) -->
        <div id="bits-buttons-container"></div>
    </div>
</body>
<script>
    // TODO add this back in once we try to submit, we dont want to be leaking data
    // console.log = () => {};
    // TODO remove this all before submitting
    const TestAuth = {userId: 468106723, channelId: 468106723}
    const TESTING = window.location.hostname === "localhost";

    DOMPurify.addHook('afterSanitizeAttributes', function (node) {
        if ('target' in node) {
            node.setAttribute('target', '_blank');
            node.setAttribute('rel', 'noreferrer');
        }
    });

    function follow_button(channelName) {
        console.log(channelName);
        window.Twitch.ext.actions.followChannel(channelName);
        console.log("finished following")
    }

    // initially set to 1080p, gets set by local player and websocket
    let playerWidth = 1920;
    let playerHeight = 1080;
    let obsOutputWidth = 1920;
    let obsOutputHeight = 1080;

    let infoWindowData = {};
    let userId = ""; // Declare userId in the global scope
    let popupTimeout; // Store the timeout ID

    // Add the drag-and-drop functionality for the obs-container
    let isDragging = false;
    let draggedElement = null;
    let rect = null;
    let dragCooldown = false; // Cooldown flag to prevent rapid dragging
    let offsetX = 0;
    let offsetY = 0;
    let draggedElementBounds = null;
    let obsScreenData = [];

    let windowBounds = {};
    const defaultBounds = {left: 0, top: 0, right: 1, bottom: 1}; // Full container

    const obsContainer = document.getElementById("obs-container");
    function updateObsScreen(data) {
        for (let obsWindow of data) {
            console.log("obsWindow", obsWindow);
            if (Array.isArray(obsWindow['data'])) {
                console.log(obsWindow['data'][0]);
                obsWindow = obsWindow['data'][0];
                console.log("obsWindow is an array, using first element", obsWindow);
            }

            console.log("obsWindow", obsWindow);
            let node = document.getElementById(obsWindow.name);
            if (node === null) {
                console.log("creating new node for", obsWindow.name);

                node = document.createElement("div");
                node.id = obsWindow.name;
                node.classList.add("draggableWindow");

                obsContainer.appendChild(node);

                // Add the new class for info popups
                if (obsWindow.hasOwnProperty("info")) {
                    node.classList.add("infoWindow");
                    const infoIcon = document.createElement("div");
                    infoIcon.classList.add("infoIcon");
                    infoIcon.innerText = "i"; // You can replace this with an icon or image

                    // Position the info icon inside the window
                    infoIcon.style.position = "absolute";
                    infoIcon.style.top = "5px";
                    infoIcon.style.right = "5px";
                    infoIcon.style.cursor = "pointer";

                    // Add event listeners to the info icon
                    addInfoIconListeners(infoIcon);

                    // Append the info icon to the window node
                    node.appendChild(infoIcon);
                }
            }
            let x = `${(obsWindow.x / obsOutputWidth) * 100}%`;
            let y = `${(obsWindow.y / obsOutputHeight) * 100}%`;

            node.style.left = x;
            node.style.top = y;
            node.style.zIndex = obsWindow.zIndex;
            console.log(obsWindow);
            console.log("width data: ", obsWindow.width, playerWidth, obsWindow.width.split('p')[0] / obsOutputWidth * playerWidth);
            console.log("height data: ", obsWindow.height, playerHeight, obsWindow.height.split('p')[0] / obsOutputHeight * playerHeight);
            node.style.width = Math.min(Math.max(obsWindow.width.split('p')[0] / obsOutputWidth * playerWidth, 0), obsOutputWidth) + "px"; // obsWindow.width;
            node.style.height = Math.min(Math.max(obsWindow.height.split('p')[0] / obsOutputHeight * playerHeight, 0), obsOutputHeight) + "px"; // obsWindow.height;
        }
    }

    function resetObsmap() {
        let units = Array.from(document.getElementsByClassName("draggableWindow"));
        if (units.length !== 0) {
            let container = document.getElementById("obs-container");
            container.style.display = "";
        }
        for (const unit of units) {
            unit.remove();
        }
    }

    function setupInfoPopupHandlers(infoIcon) {
        // Show popup on mouse over
        infoIcon.addEventListener("mouseover", (e) => {
            e.stopPropagation();
            showPopup(e.target);
        });

        // Hide popup after a delay on mouse out
        infoIcon.addEventListener("mouseout", (_) => {
            hidePopup();
        });
    }

    function addInfoIconListeners(infoIcon) {
        setupInfoPopupHandlers(infoIcon);
    }

    function showPopup(targetElement) {
        keepPopupOpen(popupTimeout); // Clear any pending timeouts

        const popup = document.getElementById("info-popup");
        const windowID = targetElement.closest('.infoWindow').id;
        const infoWindowElement = targetElement.closest('.infoWindow');
        const info = infoWindowData[windowID];

        if (info) {
            // Populate the popup with information
            // YES WE WANT IT UNINDENTED
            let markdownData = `
## ${info.title}

${info.description}`;

            marked.setOptions({
                gfm: true,       // Enable GitHub flavored markdown
                breaks: true,    // Enable line breaks
                sanitize: true, // Allow HTML tags
            });
            marked.use({
                renderer: {
                    link(token) {
                        if (token.href === "FOLLOW_BUTTON") {
                            return `<button class="follow_button" data-channel="${token.text}">${token.text}</button>`
                        }
                        return `<a href="${token.href}" target="_blank">${token.text}</a>`
                    }
                }
            })
            let html = marked.parse(markdownData);
            html = DOMPurify.sanitize(html);
            popup.innerHTML = html
            for (const button of popup.getElementsByClassName("follow_button")) {
                button.addEventListener("click", (event) => {
                    follow_button(event.target.dataset.channel)
                })
            }

            // Ensure the popup is visible to get its dimensions
            popup.classList.remove('hidden');

            // Get bounding rectangles
            const windowRect = infoWindowElement.getBoundingClientRect();
            const popupRect = popup.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // Default position: above the info icon
            let popupLeft = windowRect.left + (windowRect.width - popupRect.width) / 2;
            let popupTop = windowRect.top + (windowRect.height - popupRect.height) / 2;

            // Adjust position if the popup goes off-screen horizontally
            if (popupLeft < 5) {
                popupLeft = 5; // Minimum 5px from the left edge
            } else if (popupLeft + popupRect.width > viewportWidth - 5) {
                popupLeft = viewportWidth - popupRect.width - 5; // Minimum 5px from the right edge
            }

            // Adjust position if the popup goes off-screen vertically
            if (popupTop < 5) { // 5px padding
                popupTop = 5;
            } else if (popupTop + popupRect.height > viewportHeight - 5) {
                popupTop = viewportHeight - popupRect.height - 5;
            }

            popup.style.left = popupLeft + 'px';
            popup.style.top = popupTop + 'px';
            popup.addEventListener("mouseover", keepPopupOpen);
            popup.addEventListener("mouseout", hidePopup);
        }
    }

    function hidePopup() {
        popupTimeout = setTimeout(() => {
            const popup = document.getElementById("info-popup");
            popup.classList.add('hidden');
            popup.style.left = '-9999px'; // Move off-screen
        }, 500); // Wait for 0.5 seconds before hiding
    }

    function keepPopupOpen() {
        clearTimeout(popupTimeout); // Clear the timeout to prevent hiding
    }

    function runGameJam(auth) {
        if (userId === "")
            userId = auth.userId; // Set userId here
        let wsUrl = "wss://websocket.matissetec.dev/lobby/connect?user=" + auth.channelId;
        let socket;
        let reconnectInterval = null; // To store the interval ID for reconnection attempts

        function connectWebSocket() {
            socket = new WebSocket(wsUrl);
            resetObsmap();

            socket.addEventListener("open", (_) => {
                console.log("Connected to the WebSocket server");
                let container = document.getElementById("obs-container");
                container.style.display = "initial";
                socket.send("Hello Server!");
                if (reconnectInterval) {
                    clearInterval(reconnectInterval); // Clear the reconnect interval on successful connection
                    reconnectInterval = null;
                }
            });

            socket.addEventListener("message", (event) => {
                if (event.data === "ping") {
                    console.log("ping received");
                    return;
                }
                console.log("has data")
                console.log(event)
                let eventData = JSON.parse(event.data);

                // If the data contains the screen configuration (like the windows to display)
                if (Array.isArray(eventData.data)) {
                    obsScreenData = eventData.data;
                    console.log("Screen data received:", obsScreenData);
                    updateObsScreen(obsScreenData);
                } else {
                    eventData = JSON.parse(eventData)
                    console.log(eventData)
                    // Check if the data contains window bounds
                    if (eventData.hasOwnProperty("bounds")) {
                        // Update the windowBounds object with the received data
                        console.log("Bounds data received from WebSocket:", eventData.bounds);
                        windowBounds = eventData.bounds; // This updates the global windowBounds object
                    }
                    if (eventData.hasOwnProperty("infoWindow")) {
                        console.log("infoWindow data received from websocket: ", eventData.infoWindow)
                        infoWindowData = eventData.infoWindow
                    }
                    if (eventData.hasOwnProperty("obsSize")) {
                        console.log("obsSize data received from websocket: ", eventData.obsSize)
                        obsOutputWidth = eventData.obsSize["obsSize"]["width"]
                        obsOutputHeight = eventData.obsSize["obsSize"]["height"]
                    }
                }
            });

            socket.addEventListener("close", (_) => {
                console.log("Disconnected from the WebSocket server");
                // Attempt to reconnect every 10 seconds
                if (!reconnectInterval) {
                    reconnectInterval = setInterval(() => {
                        console.log("Attempting to reconnect...");
                        try {
                            connectWebSocket();
                        }
                        catch (error) {
                            console.log("Failed to connect to WebSocket server:", error);
                        }
                    }, 10000);
                }
            });

            socket.addEventListener("error", (event) => {
                let container = document.getElementById("obs-container");
                container.style.display = "none";
                console.log("WebSocket error, likely disconnected:", event);
            });
        }

        connectWebSocket();

        // Function to stop dragging
        window.addEventListener("mouseup", () => {
            // console.log("Mouse released");
            if (isDragging && draggedElement) {
                // Send the final position to the server
                const x = parseFloat(draggedElement.style.left) / 100;
                const y = parseFloat(draggedElement.style.top) / 100;
                const data = {
                    name: draggedElement.id, // Assuming each draggableWindow has a unique id
                    x: x,
                    y: y,
                    userId: userId,
                };
                sendMessage(JSON.stringify(data));

            }
            isDragging = false;
            draggedElement = null;
            draggedElementBounds = null; // Reset bounds
            document.body.style.cursor = ''; // Reset cursor
            dragCooldown = true; // Set cooldown
            setTimeout(() => {dragCooldown = false;}, 100); // Cooldown for 100ms
        });

        function sendMessage(message) {
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(message);
            } else {
                console.error(
                    "WebSocket is not open. Ready state:",
                    socket.readyState,
                );
            }
        }
    }

    // Function to handle dragging
    document.addEventListener("mousedown", (e) => {
        if (dragCooldown) return;

        let obsCont;
        // Ensure the draggableWindow is correctly identified even if a child element (like infoIcon) is clicked
        let target = e.target.closest(".draggableWindow");
        if (target) {
            isDragging = true;
            draggedElement = target;
            obsCont = document.getElementById("obs-container");
            rect = obsCont.getBoundingClientRect();
            document.body.style.cursor = 'grabbing';

            // Calculate the offset
            const elemRect = draggedElement.getBoundingClientRect();
            offsetX = e.clientX - elemRect.left;
            offsetY = e.clientY - elemRect.top;

            // Store the initial position of the draggedElement
            draggedElement.initialX = parseFloat(draggedElement.style.left) / 100;
            draggedElement.initialY = parseFloat(draggedElement.style.top) / 100;

            const windowID = draggedElement.id;
            console.log("this is the window bounds", windowBounds);
            draggedElementBounds = windowBounds[windowID] || defaultBounds;
        }
    });

    document.addEventListener("mousemove", (e) => {
        if (isDragging && draggedElement) {
            const x = (e.clientX - rect.left - offsetX) / rect.width;
            const y = (e.clientY - rect.top - offsetY) / rect.height;

            // Get the element's size relative to the container
            const elemWidth = draggedElement.offsetWidth / rect.width;
            const elemHeight = draggedElement.offsetHeight / rect.height;

            // Calculate the constraints based on bounds
            const minX = draggedElementBounds.left;
            const maxX = draggedElementBounds.right - elemWidth;
            const minY = draggedElementBounds.top;
            const maxY = draggedElementBounds.bottom - elemHeight;

            // Constrain x and y within the calculated bounds
            const constrainedX = Math.max(minX, Math.min(maxX, x));
            const constrainedY = Math.max(minY, Math.min(maxY, y));

            // Update the position of the dragged element
            draggedElement.style.left = constrainedX * 100 + "%";
            draggedElement.style.top = constrainedY * 100 + "%";
        }
    });

    if (TESTING) {
        // TODO: REMOVE THIS
        // TODO: IF THIS IS PUSHED FEEL FREE TO YELL AT VIV
        // TODO: VIV MESSED UP: P: P: :P
        const buttonsContainer = document.getElementById('bits-buttons-container');
        // Clear any existing buttons, this gets called every reauthorization
        buttonsContainer.innerHTML = '';

        for (let i = 0; i < 3; i++) {
            // Iterate through each product and create a button
            const button = document.createElement('button');

            const topText = document.createElement('span');
            topText.classList.add('top-text');
            topText.textContent = `TEST BIT`; // Top text (number range)

            const bottomText = document.createElement('span');
            bottomText.classList.add('bottom-text');
            bottomText.textContent = `bits 3794`; // Top text (number range)
            button.classList.add('bits-button');

            button.appendChild(topText);
            button.appendChild(document.createElement('br')); // Line break between top and bottom text
            button.appendChild(bottomText);
            buttonsContainer.appendChild(button);
        }
        runGameJam(TestAuth);
    } else {
        window.Twitch.ext.onContext((context) => {
            // Get the player's width
            let resolutions = context.displayResolution.split("x");
            let newWidth = parseInt(resolutions[0], 10);  // Update playerWidth
            let newHeight = parseInt(resolutions[1], 10); // Update playerHeight
            if (newWidth !== playerWidth || newHeight !== playerHeight) {
                playerWidth = newWidth;
                playerHeight = newHeight;
                console.log("Player width:", playerWidth);
                console.log("Player height:", playerHeight);
                updateObsScreen(obsScreenData);
            }
        });
        window.Twitch.ext.onAuthorized(function (auth) {
            Twitch.ext.bits.getProducts().then(function (products) {
                console.log(products); // [ { sku: 'abc123', cost: { type: 'bits', amount: '10' } } ]
                const buttonsContainer = document.getElementById('bits-buttons-container');
                // Clear any existing buttons, this gets called every reauthorization
                buttonsContainer.innerHTML = '';

                // Iterate through each product and create a button
                products.forEach(function (product) {
                    const button = document.createElement('button');

                    const topText = document.createElement('span');
                    topText.classList.add('top-text');
                    topText.textContent = `${product.displayName}`; // Top text (number range)

                    const bottomText = document.createElement('span');
                    bottomText.classList.add('bottom-text');
                    bottomText.textContent = `bits ${product.cost.amount}`; // Top text (number range)

                    button.appendChild(topText);
                    button.appendChild(document.createElement('br')); // Line break between top and bottom text
                    button.appendChild(bottomText);
                    // Set the button text to display the amount of bits

                    // Assign the SKU as a data attribute for later reference
                    button.dataset.sku = product.sku;

                    // Optionally, add a class for styling
                    button.classList.add('bits-button');

                    // Add an event listener for button clicks
                    button.addEventListener('click', function () {
                        // Handle the button click
                        console.log("just clicked ", this.dataset.sku)
                        Twitch.ext.bits.useBits(this.dataset.sku);
                    });

                    // Append the button to the container
                    buttonsContainer.appendChild(button);
                });

                // Make sure the bits buttons container is visible
                document.getElementById('top-left-menu').classList.add('visible');
            }).catch(function (error) {
                console.error('Error fetching Bits products:', error);
            });
            runGameJam(auth);
        });

        window.Twitch.ext.bits.onTransactionComplete(function (transactionObject) {
            console.log("we just completed the transaction")
            // console.log(transactionObject);
            userId = JSON.parse(atob(transactionObject['transactionReceipt'].split('.')[1]))['data']['userId']
            console.log(userId);
            const data = {
                r: getRandomColor(),
                g: getRandomColor(),
                b: getRandomColor(),
            };
            console.log("new color data:", data);
            const tWindows = document.getElementsByClassName("draggableWindow");
            for (let i = 0; i < tWindows.length; i++) {
                tWindows[i].style.setProperty("--r", data.r);
                tWindows[i].style.setProperty("--g", data.g);
                tWindows[i].style.setProperty("--b", data.b);
            }
        });

        function getRandomColor() {
            return Math.floor(Math.random() * 255);
        }
    }
</script>

</html>
